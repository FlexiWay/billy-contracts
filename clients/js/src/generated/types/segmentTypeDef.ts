/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */

import { GetDataEnumKind, GetDataEnumKindContent, Serializer, dataEnum, struct, tuple, u64 } from '@metaplex-foundation/umi/serializers';


export type SegmentTypeDef = { __kind: "Constant", fields: [bigint];  } | { __kind: "Linear", fields: [bigint, bigint];  } | { __kind: "Exponential", fields: [bigint, bigint, bigint];  };

export type SegmentTypeDefArgs = { __kind: "Constant", fields: [number | bigint];  } | { __kind: "Linear", fields: [number | bigint, number | bigint];  } | { __kind: "Exponential", fields: [number | bigint, number | bigint, number | bigint];  };


export function getSegmentTypeDefSerializer(): Serializer<SegmentTypeDefArgs, SegmentTypeDef> {
  return dataEnum<SegmentTypeDef>([['Constant', struct<GetDataEnumKindContent<SegmentTypeDef, 'Constant'>>([['fields', tuple([u64()])]])], ['Linear', struct<GetDataEnumKindContent<SegmentTypeDef, 'Linear'>>([['fields', tuple([u64(), u64()])]])], ['Exponential', struct<GetDataEnumKindContent<SegmentTypeDef, 'Exponential'>>([['fields', tuple([u64(), u64(), u64()])]])]], { description: 'SegmentTypeDef' }) as Serializer<SegmentTypeDefArgs, SegmentTypeDef>;
}


      // Data Enum Helpers.
            export function segmentTypeDef(kind: 'Constant', data: GetDataEnumKindContent<SegmentTypeDefArgs, 'Constant'>['fields']): GetDataEnumKind<SegmentTypeDefArgs, 'Constant'>;
                export function segmentTypeDef(kind: 'Linear', data: GetDataEnumKindContent<SegmentTypeDefArgs, 'Linear'>['fields']): GetDataEnumKind<SegmentTypeDefArgs, 'Linear'>;
                export function segmentTypeDef(kind: 'Exponential', data: GetDataEnumKindContent<SegmentTypeDefArgs, 'Exponential'>['fields']): GetDataEnumKind<SegmentTypeDefArgs, 'Exponential'>;
        export function segmentTypeDef<K extends SegmentTypeDefArgs['__kind']>(
    kind: K,
    data?: any,
  ): Extract<SegmentTypeDefArgs, { __kind: K }> {
    return Array.isArray(data) ? { __kind: kind, fields: data } : { __kind: kind, ...(data ?? {}) };
  }
  export function isSegmentTypeDef<K extends SegmentTypeDef['__kind']>(
    kind: K,
    value: SegmentTypeDef,
  ): value is SegmentTypeDef & { __kind: K } {
    return value.__kind === kind;
  };
